#include <bits/stdc++.h>

using namespace std;

/* Thor
Thor is getting used to the Earth. As a gift Loki gave him a smartphone. There are n applications on this phone. Thor is fascinated by this phone. 
He has only one minor issue: he can't count the number of unread notifications generated by those applications (maybe Loki put a curse on it so he can't).

q events are about to happen (in chronological order). They are of three types:
    Application x generates a notification (this new notification is unread).
    Thor reads all notifications generated so far by application x (he may re-read some notifications).
    Thor reads the first t notifications generated by phone applications (notifications generated in first t events of the first type). It's guaranteed that there were at 
        least t events of the first type before this event. Please note that he doesn't read first t unread notifications, he just reads the very first t notifications generated on 
        his phone and he may re-read some of them in this operation.
Please help Thor and tell him the number of unread notifications after each event. You may assume that initially there are no notifications in the phone.

Input: The first line of input contains two integers n and q (1 ≤ n, q ≤ 300 000) — the number of applications and the number of events to happen.
The next q lines contain the events. The i-th of these lines starts with an integer typei — type of the i-th event. If typei = 1 or typei = 2 then it is followed by an integer xi. 
Otherwise it is followed by an integer ti (1 ≤ typei ≤ 3, 1 ≤ xi ≤ n, 1 ≤ ti ≤ q).

Output: Print the number of unread notifications after each event.
*/

/* OPTIMIZED APPROACH WITH SETS */
int main(){

    // retrieve number of applications and number of events to occur
    long int numApplications, numEvents;
    cin >> numApplications >> numEvents;

    // declare a set to store all unread notifications; characteristic is that when you erase an element at a certain position, position of other elements does not change but size does
    // stores the event number when the notification was generated
    set<long int> allUnreadNotifications;

    // declare a 2D vector for each application that stores the event number when the notification was generated
    vector< vector<long int> > applicationUnread(numApplications + 1);

    // declare a vector to store all notifications
    vector<long int> allNotifications;

    // declare variable to track the eventNum the last time we 'read all'
    long int lastReadAll = 0;

    // loop for the number of events
    for(long int eventNum = 0; eventNum < numEvents; eventNum++){
        // for each event, find the event type and the command
        int eventType, command;
        cin >> eventType >> command;

        // application 'command' generates a new notification
        if(eventType == 1){
            // insert the event number when the notification was generated into 'allUnreadNotifications' and the vector for the specific application
            applicationUnread[command].push_back(eventNum);
            allUnreadNotifications.insert(eventNum);
            // insert event number into all notifications vector
            allNotifications.push_back(eventNum);
        } else if(eventType == 2){
            // loop through all unread notifications for the specified application
            for(int appUnread = 0; appUnread < applicationUnread[command].size(); appUnread++){
                // find the position in the 'allUnreadNotifications' set by accessing the 2D vector for the specific application
                allUnreadNotifications.erase(applicationUnread[command][appUnread]);
            }
            // after erasing the notifications inside 'allUnreadNotifications', clear the 2D vector for the current application
            applicationUnread[command].clear();
        } else if(eventType == 3){
            // loop from the event number when we last 'read all' until the command 
            while(lastReadAll < command){
                // first find the event number when the notification was generated by accessing all notifications, then erasing that value in the set
                allUnreadNotifications.erase(allNotifications[lastReadAll]);
                // increment last notification read
                lastReadAll++;
            }
        }

        printf("%ld\n", allUnreadNotifications.size());
    }
}

// /* MODIFICATION STILL EXCEEDS TIME LIMIT */
// int main(){

//     // retrieve number of applications and number of events to occur
//     long int numApplications, numEvents;
//     cin >> numApplications >> numEvents;

//     // declare a vector (index = application number (0 indexed), value = unread notifications for this application; initialized to 0)
//     vector<int> applicationUnread(numApplications, 0);

//     // declare another vector (index = application number (0 indexed), value = time that all notifications were read for this application, initialized to -1 indicating haven't been 'read all' yet
//     vector<int> applicationLastRead(numApplications, -1);

//     // declare a 2nd vector (key = application number, value = read (1) or unread (0)) to track all notifications (bit only changed in event type 3)
//     vector< pair<int, int> > allNotifications;

//     // declare an integer to track the last position from previous read first n notifications
//     int lastNotificationRead = 0;

//     // declare variable to track number of notifications generated in total (initialize to 0)
//     int totalNotificationNumber = 0;

//     // loop for the number of events
//     while(numEvents){
//         // for each event, find the event type and the command
//         int eventType, command;
//         cin >> eventType >> command;

//         // application 'command' generates a new notification
//         if(eventType == 1){
//             // append new notification for application 'command' into pair vector
//             allNotifications.push_back(make_pair(command, 0));
//             // increment number of unread notifications for application 'command'
//             applicationUnread[command - 1]++;
//             // increment number of notifications generated in total
//             totalNotificationNumber++;
//         } else if(eventType == 2){
//         // read all notification generated by application 'command'
//             // update number of unread notifications for application 'command' to 0
//             applicationUnread[command - 1] = 0;

//             /* ORIGINAL IMPLEMENTATION TIMES OUT */
//             // // need to go through entire allNotifications and if the application is 'command', set its bit to 1
//             // for(auto iterator = allNotifications.begin(); iterator != allNotifications.end(); iterator++){
//             //     if(iterator->first == command){
//             //         iterator->second = 1;
//             //     }
//             // }

//             /* MODIFIED IMPLEMENTATION STILL TIMES OUT */
//             // track how many notifications were generated when application 'command' was last fully read
//             applicationLastRead[command - 1] = totalNotificationNumber;

//         } else if(eventType == 3){
//         // read first 'command' notifications to have arrived

//             // loop through the first 'command' notifications and check if it has been read already (if not, then mark it as read); 0 indexed 
//             for(int notificationNum = lastNotificationRead; notificationNum < command; notificationNum++){
//                 // MODIFIED IMPLEMENTATION: need additional check; 1st Case: the application has never been 'all read', so if allplicationLastRead stores -1 for the application, let it pass so we can properly decrement it; 2nd Case: the application has been 'all read' before, in that case, we only pass it on if the number of total notifications when it was last 'all read' is greater than current notificationNum
//                 if(allNotifications[notificationNum].second == 0 && (((applicationLastRead[allNotifications[notificationNum].first - 1] <= notificationNum) && (applicationLastRead[allNotifications[notificationNum].first - 1] > -1)) || (applicationLastRead[allNotifications[notificationNum].first - 1] == -1))){
//                     allNotifications[notificationNum].second = 1;
//                     // get the application number and decrement 
//                     applicationUnread[allNotifications[notificationNum].first - 1]--;
//                 }
//             }
//             lastNotificationRead = command - 1;
//         }

//         // // go through all applilcations and count number of unread notifications, then print it
//         // int remainingUnread = 0;
//         // for(int application = 0; application < numApplications; application++){
//         //     remainingUnread += applicationUnread[application];
//         // }

//         int remainingUnread = accumulate(applicationUnread.begin(), applicationUnread.end(), 0);

//         printf("%d\n", remainingUnread);

//         numEvents--;
//     }
// }


